---
title: "Modélisation et prédiction de données fonctionnelles issues du sport"
author: "Arthur Leroy"
date: "2024-05-31"
output: html_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  fig.align = 'center',
  dpi = 300,
  out.width = "80%"
)
```


## Installation/chargement des packages
``` {r}
library(MagmaClustR)
library(tidyverse)
```

## Données fonctionnelles, format et visualisation

Une particularité des données fonctionnelles vient du fait qu'elle soit observé sur un continuum, et en conséquence que la variable d'entrée (explicative, input) peut être observée irrégulièrement ou pour de nombreuses valeurs différentes d'un individu à l'autre. Pour ce type de données, il est en général conseillé d'utiliser un format dit 'tidy', c'est à dire dans lequel chaque ligne d'un data frame correspond à un individu, et chaque colonne à une variable. Par exemple, la base de données `swimmers` propose un cadre usuel de données longitudinales. Cet exemple présente un ensemble de performances (en sec) de 2345 nageurs et nageuses (de tous niveaux) sur 100m nage libre, pendant leur carrière entre 10 et 20 ans. 

```{r }
swimmers
```

Pour la suite de ce document, nous proposons d'utiliser un sous ensemble de 100 nageuses pour illustrer différentes approches de modélisation de données fonctionnelles tout en conservant des temps raisonnables. Pour des raisons de convention utilisée dans le package `MagmaClustR`, nous renommons la variable d'entée `Age` en tant que `Input`, et `Output` pour la variable `Performance`.

```{r}
db = swimmers %>% 
  as_tibble %>% 
  filter(Gender == 2) %>%
  select(- Gender) %>% 
  filter(ID %in% unique(ID)[1:100]) %>% 
  rename(Input = Age, Output = Performance) 

db
```

Une visualisation des données brute nous montre la diversité des performances, et la difficulté de tirer de l'information par l'observation sans modélisation adaptée. 

```{r}
ggplot(db) +
  geom_point(aes(x = Input, y = Output, color = ID)) +
  guides(color = 'none') + 
  theme_classic()
```

### Modélisation

Une manière simple de reconstruire un signal fonctionnel individuel à partir de données ponctuelles peut être d'utiliser une décomposition dans une base de fonctions, telle que les splines. 

```{r}
## Extraction d'un individu
db_1 = db %>% filter(ID == db$ID[1])

## Lissage par base de splines et prédiction
spline_1 = smooth.spline(db_1$Input, db_1$Output)
preds <- predict(spline_1, seq(10, 18, 0.1)) %>% as_tibble

## Visualisation
ggplot() + 
  geom_line(data = preds, aes(x = x, y = y)) +
  geom_point(data = db_1, aes(x = Input, y = Output)) +
  theme_classic()
```
### GP
```{r}
mod_1 = train_gp(db_1)
pred_gp(db_1, hp = mod_1, grid_inputs = seq(10, 18, 0.1))
```

### Magma

```{r}
db_train <- db %>% subset(ID %in% unique(db$ID)[1:20])
db_pred <- db %>% subset(ID == unique(db$ID)[51]) %>% filter(Input < 16)
db_test <- db %>% subset(ID == unique(db$ID)[51]) %>%  filter(Input >= 16)
```

```{r}
mod = train_magma(db_train)
pred = pred_magma(db_pred, trained_model = mod, grid_inputs = seq(12, 20, 0.1))
```


### Training and prediction with Magma 

```{r train_and_predict_Magma}
model <- train_magma(data = magma_train, common_hp = F)

pred  <- pred_magma(data = magma_pred,
                    trained_model = model, 
                    grid_inputs = seq(0,10, 0.01))
```

Note that the `common_hp` and `grid_inputs` arguments are optional. They respectively indicate that a specific set of hyper-parameters is trained for each curve, and control the grid of values on which the prediction is performed.

### Display the resulting predictions

Several other arguments are available in dedicated plotting functions to offer extended options in the display of results. For instance, the GP predictions can be represented as a heatmap of probabilities:

```{r display_Magma}
plot_gp(pred_gp = pred,
        data = magma_pred,
        data_train = magma_train,
        prior_mean = model$hyperpost$mean,
        heatmap = TRUE) 
```

Additionally, it is also possible to create animated representations by using functions that generate GIFs. For instance, below, the true testing points have been represented as red dots and we can observe how the prediction evolves as we add more data points to our prediction dataset.

## Example: MagmaClust

Here is a basic example on how to simulate a dataset with the adequate format, then train a MagmaClust model and use it to perform simultaneous clustering and predictions.

### Data generation

```{r generate data MagmaClust}
## Simulate a dataset containing 3 clusters of 4 individuals, each observed at 10 input locations
set.seed(4) 
data_magmaclust <- simu_db(M = 4, N = 10, K = 3, common_input = FALSE) 
## Split individuals into training and prediction sets, and define test points
list_ID = unique(data_magmaclust$ID)
magmaclust_train <- data_magmaclust %>% subset(ID %in% list_ID[1:11])
magmaclust_pred <- data_magmaclust %>% subset(ID == list_ID[12]) %>% head(5)
magmaclust_test <- data_magmaclust %>% subset(ID == list_ID[12]) %>% tail(5)

data_magmaclust
```


### Training and prediction with MagmaClust

```{r train_and_predict_MagmaClust, message=FALSE}
model_clust <- train_magmaclust(data = magmaclust_train)

pred_clust  <- pred_magmaclust(data = magmaclust_pred,
                               trained_model = model_clust,
                               grid_inputs = seq(0, 10, 0.01), 
                               plot = FALSE)
```


### Display the resulting predictions

As before, a specific plotting function is provided. For MagmaClust, we advise to use the heatmap representation in priority, as a mixture of GPs may not be unimodal in general (and thus prevents the definition of Credible Interval).

```{r display_MagmaClust, message=FALSE}
## Allocate individuals to their most probable cluster to colour them by clusters afterwards
data_train_with_clust = data_allocate_cluster(model_clust)

plot_magmaclust(pred = pred_clust,
                cluster = "all",
                data = magmaclust_pred,
                data_train = data_train_with_clust,
                col_clust = TRUE,
                prior_mean = model_clust$hyperpost$mean,
                y_grid = seq(10, 55, 0.5),
                heatmap = TRUE) 
```

## Example: in 2-dimensions

Although unidimensional-input problems are easier to visualise, both Magma and MagmaClust can also be applied with as many covariates as desired in the model.

### Data generation
```{r generate data 2-D}
## Dataset with 11 individuals, 10 reference input locations and a covariate
set.seed(5) 
data_dim2 <- simu_db(M = 11, N = 10, covariate = TRUE) 
## Split individuals into training and prediction sets, and define test points
dim2_train <- data_dim2 %>% subset(ID %in% 1:10)
dim2_pred <- data_dim2 %>% subset(ID == 11)

data_dim2
```

### Training and prediction with Magma 

```{r train_and_predict_Magma_in_2-D, message=FALSE, warning=FALSE}
model_dim2 <- train_magma(data = dim2_train)

pred_dim2  <- pred_magma(data = dim2_pred,
                         trained_model = model_dim2)
```